"""Example bridge: BrainLink (ThinkGear) → ML/heuristics → socket JSON for the game.

This script ingests ThinkGear/BrainLink data, runs it through an optional ML model,
and forwards the resulting lean/jump commands to the tightrope game via the socket
interface (`main.py --socket-input`).

Usage example:
    python tools/brainlink_socket_bridge.py \
        --thinkgear-host 127.0.0.1 \
        --thinkgear-port 13854 \
        --game-port 4789 \
        --profile assets/blink_energy_profile.json \
        --model-module my_ml_controller

The optional ``--model-module`` should define ``predict(packet: dict) -> dict`` and
may return values such as ``{"lean": 0.2, "jump": False}``.  When no module is
supplied, the script falls back to using meditation for lean and the energy profile
for blink detection.
"""

from __future__ import annotations

import argparse
import importlib
import json
import socket
import sys
import time
from pathlib import Path
from types import ModuleType
from typing import Callable, Optional

ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

from balance_game.blink_detector import BlinkProfile, EnergyBlinkDetector  # noqa: E402

def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="BrainLink (ThinkGear) to game socket bridge.")
    parser.add_argument("--thinkgear-host", default="127.0.0.1", help="ThinkGear Connector host.")
    parser.add_argument("--thinkgear-port", type=int, default=13854, help="ThinkGear Connector port.")
    parser.add_argument("--game-host", default="127.0.0.1", help="Game socket host.")
    parser.add_argument("--game-port", type=int, default=4789, help="Game socket port.")
    parser.add_argument(
        "--model-module",
        help="Python module path exposing predict(packet: dict) -> dict for custom ML integration.",
    )
    parser.add_argument(
        "--fallback-blink-threshold",
        type=int,
        default=55,
        help="Blink strength threshold for the built-in fallback heuristic.",
    )
    parser.add_argument(
        "--profile",
        default="assets/blink_energy_profile.json",
        help="Blink energy profile JSON (generated by tools/train_blink_energy.py).",
    )
    return parser.parse_args()


def load_predict_function(module_name: Optional[str]) -> Optional[Callable[[dict], dict]]:
    if not module_name:
        return None
    module: ModuleType = importlib.import_module(module_name)
    if not hasattr(module, "predict"):
        raise AttributeError(f"Module {module_name!r} must define a predict(packet: dict) -> dict function.")
    predict = getattr(module, "predict")
    if not callable(predict):
        raise TypeError("predict attribute must be callable.")
    return predict  # type: ignore[return-value]


def fallback_lean(packet: dict) -> dict:
    """Fallback heuristic for lean based on meditation score."""
    meditation = packet.get("meditation")
    output: dict[str, float | bool] = {}
    if meditation is not None:
        try:
            meditation = float(meditation)
        except (TypeError, ValueError):
            meditation = 50.0
        output["lean"] = max(-1.0, min(1.0, (meditation - 50.0) / 40.0))
    return output


def thinkgear_stream(host: str, port: int):
    with socket.create_connection((host, port), timeout=5.0) as sock:
        sock.settimeout(1.0)
        handshake = json.dumps({"enableRawOutput": True, "format": "Json"}).encode("utf-8") + b"\n"
        sock.sendall(handshake)
        buffer = bytearray()
        while True:
            try:
                data = sock.recv(4096)
            except socket.timeout:
                continue
            if not data:
                break
            buffer.extend(data)
            while b"\n" in buffer:
                line, _, remainder = buffer.partition(b"\n")
                buffer = bytearray(remainder)
                line = line.strip()
                if not line:
                    continue
                try:
                    packet = json.loads(line.decode("utf-8"))
                except json.JSONDecodeError:
                    continue
                yield packet


def main() -> None:
    args = parse_args()
    predict = load_predict_function(args.model_module)

    profile_path = Path(args.profile).expanduser()
    energy_detector: Optional[EnergyBlinkDetector] = None
    if profile_path.exists():
        try:
            profile = BlinkProfile.from_json(profile_path)
            energy_detector = EnergyBlinkDetector.from_profile(profile)
            print(f"[INFO] Loaded blink profile from {profile_path}")
        except Exception as exc:  # noqa: BLE001
            print(f"[WARN] Failed to load profile {profile_path}: {exc}")
    else:
        print(f"[WARN] Blink profile {profile_path} not found. Falling back to blinkStrength threshold.")
        profile = None  # type: ignore[assignment]

    try:
        game_socket = socket.create_connection((args.game_host, args.game_port))
    except OSError as exc:
        print(f"[ERROR] Unable to connect to game socket ({exc}). Did you run main.py --socket-input ?", file=sys.stderr)
        sys.exit(1)

    with game_socket:
        last_jump_time = 0.0
        for packet in thinkgear_stream(args.thinkgear_host, args.thinkgear_port):
            control: dict[str, float | bool] = {}

            # User model takes precedence if provided.
            if predict:
                try:
                    output = predict(packet)  # type: ignore[call-arg]
                except Exception as exc:  # noqa: BLE001
                    print(f"[WARN] model predict failed: {exc}")
                    output = {}
                if isinstance(output, dict):
                    control.update(output)
            else:
                control.update(fallback_lean(packet))

            raw_value = packet.get("rawEeg")
            if energy_detector is not None and raw_value is not None:
                try:
                    raw_float = float(raw_value)
                except (TypeError, ValueError):
                    raw_float = None
                if raw_float is not None and energy_detector.process_sample(raw_float):
                    control["jump"] = True
                    last_jump_time = time.perf_counter()

            # If no energy profile, fall back to blinkStrength threshold when available.
            if "jump" not in control and energy_detector is None:
                blink_strength = packet.get("blinkStrength")
                if isinstance(blink_strength, (int, float)) and blink_strength >= args.fallback_blink_threshold:
                    control["jump"] = True
                    last_jump_time = time.perf_counter()

            if not control:
                continue

            # Auto-release if the sender never emitted a False pulse.
            if control.get("jump"):
                last_jump_time = time.perf_counter()
            elif last_jump_time and time.perf_counter() - last_jump_time > 0.25:
                control["jump"] = False

            try:
                payload = json.dumps(control).encode("utf-8") + b"\n"
                game_socket.sendall(payload)
            except OSError:
                break


if __name__ == "__main__":
    main()
